{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n *\n */\n\n/* eslint-disable complexity, max-statements */\nvar http = require('./http');\n\nvar util = require('./util');\n\nvar oauthUtil = require('./oauthUtil');\n\nvar Q = require('q');\n\nvar sdkCrypto = require('./crypto');\n\nvar AuthSdkError = require('./errors/AuthSdkError');\n\nvar OAuthError = require('./errors/OAuthError');\n\nvar config = require('./config');\n\nvar cookies = require('./browser/browserStorage').storage;\n\nvar PKCE = require('./pkce');\n\nfunction decodeToken(token) {\n  var jwt = token.split('.');\n  var decodedToken;\n\n  try {\n    decodedToken = {\n      header: JSON.parse(util.base64UrlToString(jwt[0])),\n      payload: JSON.parse(util.base64UrlToString(jwt[1])),\n      signature: jwt[2]\n    };\n  } catch (e) {\n    throw new AuthSdkError('Malformed token');\n  }\n\n  return decodedToken;\n}\n\nfunction verifyToken(sdk, token, validationParams) {\n  return new Q().then(function () {\n    if (!token || !token.idToken) {\n      throw new AuthSdkError('Only idTokens may be verified');\n    }\n\n    var jwt = decodeToken(token.idToken);\n    var validationOptions = {\n      clientId: sdk.options.clientId,\n      issuer: sdk.options.issuer || sdk.options.url,\n      ignoreSignature: sdk.options.ignoreSignature\n    };\n    util.extend(validationOptions, validationParams); // Standard claim validation\n\n    oauthUtil.validateClaims(sdk, jwt.payload, validationOptions); // If the browser doesn't support native crypto or we choose not\n    // to verify the signature, bail early\n\n    if (validationOptions.ignoreSignature == true || !sdk.features.isTokenVerifySupported()) {\n      return token;\n    }\n\n    return oauthUtil.getKey(sdk, token.issuer, jwt.header.kid).then(function (key) {\n      return sdkCrypto.verifyToken(token.idToken, key);\n    }).then(function (valid) {\n      if (!valid) {\n        throw new AuthSdkError('The token signature is not valid');\n      }\n\n      return token;\n    });\n  });\n}\n\nfunction addPostMessageListener(sdk, timeout, state) {\n  var deferred = Q.defer();\n\n  function responseHandler(e) {\n    if (!e.data || e.data.state !== state) {\n      // A message not meant for us\n      return;\n    } // Configuration mismatch between saved token and current app instance\n    // This may happen if apps with different issuers are running on the same host url\n    // If they share the same storage key, they may read and write tokens in the same location.\n    // Common when developing against http://localhost\n\n\n    if (e.origin !== sdk.options.url) {\n      return deferred.reject(new AuthSdkError('The request does not match client configuration'));\n    }\n\n    deferred.resolve(e.data);\n  }\n\n  oauthUtil.addListener(window, 'message', responseHandler);\n  return deferred.promise.timeout(timeout || 120000, new AuthSdkError('OAuth flow timed out')).fin(function () {\n    oauthUtil.removeListener(window, 'message', responseHandler);\n  });\n}\n\nfunction addFragmentListener(sdk, windowEl, timeout) {\n  var deferred = Q.defer();\n\n  function hashChangeHandler() {\n    /*\n      We are only able to access window.location.hash on a window\n      that has the same domain. A try/catch is necessary because\n      there's no other way to determine that the popup is in\n      another domain. When we try to access a window on another\n      domain, an error is thrown.\n    */\n    try {\n      if (windowEl && windowEl.location && windowEl.location.hash) {\n        deferred.resolve(oauthUtil.hashToObject(windowEl.location.hash));\n      } else if (windowEl && !windowEl.closed) {\n        setTimeout(hashChangeHandler, 500);\n      }\n    } catch (err) {\n      setTimeout(hashChangeHandler, 500);\n    }\n  }\n\n  hashChangeHandler();\n  return deferred.promise.timeout(timeout || 120000, new AuthSdkError('OAuth flow timed out'));\n}\n\nfunction exchangeCodeForToken(sdk, oauthParams, authorizationCode, urls) {\n  // PKCE authorization_code flow\n  // Retrieve saved values and build oauthParams for call to /token\n  var meta = PKCE.loadMeta(sdk);\n  var getTokenParams = {\n    clientId: oauthParams.clientId,\n    authorizationCode: authorizationCode,\n    codeVerifier: meta.codeVerifier,\n    redirectUri: meta.redirectUri\n  };\n  return PKCE.getToken(sdk, getTokenParams, urls).then(function (res) {\n    validateResponse(res, getTokenParams);\n    return res;\n  }).fin(function () {\n    PKCE.clearMeta(sdk);\n  });\n}\n\nfunction validateResponse(res, oauthParams) {\n  if (res['error'] || res['error_description']) {\n    throw new OAuthError(res['error'], res['error_description']);\n  }\n\n  if (res.state !== oauthParams.state) {\n    throw new AuthSdkError('OAuth flow response state doesn\\'t match request state');\n  }\n}\n\nfunction handleOAuthResponse(sdk, oauthParams, res, urls) {\n  urls = urls || {};\n  var responseType = oauthParams.responseType;\n  var scopes = util.clone(oauthParams.scopes);\n  var clientId = oauthParams.clientId || sdk.options.clientId;\n  return new Q().then(function () {\n    validateResponse(res, oauthParams); // We do not support \"hybrid\" scenarios where the response includes both a code and a token.\n    // If the response contains a code it is used immediately to obtain new tokens.\n\n    if (res['code']) {\n      responseType = ['token', 'id_token']; // what we expect the code to provide us\n\n      return exchangeCodeForToken(sdk, oauthParams, res['code'], urls);\n    }\n\n    return res;\n  }).then(function (res) {\n    var tokenDict = {};\n\n    if (res['access_token']) {\n      tokenDict['token'] = {\n        accessToken: res['access_token'],\n        expiresAt: Number(res['expires_in']) + Math.floor(Date.now() / 1000),\n        tokenType: res['token_type'],\n        scopes: scopes,\n        authorizeUrl: urls.authorizeUrl,\n        userinfoUrl: urls.userinfoUrl\n      };\n    }\n\n    if (res['id_token']) {\n      var jwt = sdk.token.decode(res['id_token']);\n      var idToken = {\n        idToken: res['id_token'],\n        claims: jwt.payload,\n        expiresAt: jwt.payload.exp,\n        scopes: scopes,\n        authorizeUrl: urls.authorizeUrl,\n        issuer: urls.issuer,\n        clientId: clientId\n      };\n      var validationParams = {\n        clientId: clientId,\n        issuer: urls.issuer,\n        nonce: oauthParams.nonce\n      };\n\n      if (oauthParams.ignoreSignature !== undefined) {\n        validationParams.ignoreSignature = oauthParams.ignoreSignature;\n      }\n\n      return verifyToken(sdk, idToken, validationParams).then(function () {\n        tokenDict['id_token'] = idToken;\n        return tokenDict;\n      });\n    }\n\n    return tokenDict;\n  }).then(function (tokenDict) {\n    if (!Array.isArray(responseType)) {\n      return tokenDict[responseType];\n    } // Validate response against tokenTypes\n\n\n    var validateTokenTypes = ['token', 'id_token'];\n    validateTokenTypes.filter(function (key) {\n      return responseType.indexOf(key) !== -1;\n    }).forEach(function (key) {\n      if (!tokenDict[key]) {\n        throw new AuthSdkError('Unable to parse OAuth flow response: ' + key + ' was not returned.');\n      }\n    }); // Create token array in the order of the responseType array\n\n    return responseType.map(function (item) {\n      return tokenDict[item];\n    });\n  });\n}\n\nfunction getDefaultOAuthParams(sdk) {\n  return {\n    pkce: sdk.options.pkce || false,\n    clientId: sdk.options.clientId,\n    redirectUri: sdk.options.redirectUri || window.location.href,\n    responseType: 'id_token',\n    responseMode: 'okta_post_message',\n    state: oauthUtil.generateState(),\n    nonce: oauthUtil.generateNonce(),\n    scopes: ['openid', 'email'],\n    ignoreSignature: sdk.options.ignoreSignature\n  };\n}\n\nfunction convertOAuthParamsToQueryParams(oauthParams) {\n  // Quick validation\n  if (!oauthParams.clientId) {\n    throw new AuthSdkError('A clientId must be specified in the OktaAuth constructor to get a token');\n  }\n\n  if (util.isString(oauthParams.responseType) && oauthParams.responseType.indexOf(' ') !== -1) {\n    throw new AuthSdkError('Multiple OAuth responseTypes must be defined as an array');\n  } // Convert our params to their actual OAuth equivalents\n\n\n  var oauthQueryParams = util.removeNils({\n    'client_id': oauthParams.clientId,\n    'code_challenge': oauthParams.codeChallenge,\n    'code_challenge_method': oauthParams.codeChallengeMethod,\n    'display': oauthParams.display,\n    'idp': oauthParams.idp,\n    'idp_scope': oauthParams.idpScope,\n    'login_hint': oauthParams.loginHint,\n    'max_age': oauthParams.maxAge,\n    'nonce': oauthParams.nonce,\n    'prompt': oauthParams.prompt,\n    'redirect_uri': oauthParams.redirectUri,\n    'response_mode': oauthParams.responseMode,\n    'response_type': oauthParams.responseType,\n    'sessionToken': oauthParams.sessionToken,\n    'state': oauthParams.state\n  });\n  ['idp_scope', 'response_type'].forEach(function (mayBeArray) {\n    if (Array.isArray(oauthQueryParams[mayBeArray])) {\n      oauthQueryParams[mayBeArray] = oauthQueryParams[mayBeArray].join(' ');\n    }\n  });\n\n  if (oauthParams.responseType.indexOf('id_token') !== -1 && oauthParams.scopes.indexOf('openid') === -1) {\n    throw new AuthSdkError('openid scope must be specified in the scopes argument when requesting an id_token');\n  } else {\n    oauthQueryParams.scope = oauthParams.scopes.join(' ');\n  }\n\n  return oauthQueryParams;\n}\n\nfunction buildAuthorizeParams(oauthParams) {\n  var oauthQueryParams = convertOAuthParamsToQueryParams(oauthParams);\n  return util.toQueryParams(oauthQueryParams);\n}\n/*\n * Retrieve an idToken from an Okta or a third party idp\n *\n * Two main flows:\n *\n *  1) Exchange a sessionToken for a token\n *\n *    Required:\n *      clientId: passed via the OktaAuth constructor or into getToken\n *      sessionToken: 'yourtoken'\n *\n *    Optional:\n *      redirectUri: defaults to window.location.href\n *      scopes: defaults to ['openid', 'email']\n *\n *    Forced:\n *      prompt: 'none'\n *      responseMode: 'okta_post_message'\n *      display: undefined\n *\n *  2) Get a token from an idp\n *\n *    Required:\n *      clientId: passed via the OktaAuth constructor or into getToken\n *\n *    Optional:\n *      redirectUri: defaults to window.location.href\n *      scopes: defaults to ['openid', 'email']\n *      idp: defaults to Okta as an idp\n *      prompt: no default. Pass 'none' to throw an error if user is not signed in\n *\n *    Forced:\n *      display: 'popup'\n *\n *  Only common optional params shown. Any OAuth parameters not explicitly forced are available to override\n *\n * @param {Object} oauthOptions\n * @param {String} [oauthOptions.clientId] ID of this client\n * @param {String} [oauthOptions.redirectUri] URI that the iframe or popup will go to once authenticated\n * @param {String[]} [oauthOptions.scopes] OAuth 2.0 scopes to request (openid must be specified)\n * @param {String} [oauthOptions.idp] ID of an external IdP to use for user authentication\n * @param {String} [oauthOptions.sessionToken] Bootstrap Session Token returned by the Okta Authentication API\n * @param {String} [oauthOptions.prompt] Determines whether the Okta login will be displayed on failure.\n *                                       Use 'none' to prevent this behavior\n *\n * @param {Object} options\n * @param {Integer} [options.timeout] Time in ms before the flow is automatically terminated. Defaults to 120000\n * @param {String} [options.popupTitle] Title dispayed in the popup.\n *                                      Defaults to 'External Identity Provider User Authentication'\n */\n\n\nfunction getToken(sdk, oauthOptions, options) {\n  oauthOptions = oauthOptions || {};\n  options = options || {};\n  return prepareOauthParams(sdk, oauthOptions).then(function (oauthParams) {\n    // Start overriding any options that don't make sense\n    var sessionTokenOverrides = {\n      prompt: 'none',\n      responseMode: 'okta_post_message',\n      display: null\n    };\n    var idpOverrides = {\n      display: 'popup'\n    };\n\n    if (oauthOptions.sessionToken) {\n      util.extend(oauthParams, sessionTokenOverrides);\n    } else if (oauthOptions.idp) {\n      util.extend(oauthParams, idpOverrides);\n    } // Use the query params to build the authorize url\n\n\n    var requestUrl, endpoint, urls;\n\n    try {\n      // Get authorizeUrl and issuer\n      urls = oauthUtil.getOAuthUrls(sdk, oauthParams, options);\n      endpoint = oauthOptions.codeVerifier ? urls.tokenUrl : urls.authorizeUrl;\n      requestUrl = endpoint + buildAuthorizeParams(oauthParams);\n    } catch (e) {\n      return Q.reject(e);\n    } // Determine the flow type\n\n\n    var flowType;\n\n    if (oauthParams.sessionToken || oauthParams.display === null) {\n      flowType = 'IFRAME';\n    } else if (oauthParams.display === 'popup') {\n      flowType = 'POPUP';\n    } else {\n      flowType = 'IMPLICIT';\n    }\n\n    function getOrigin(url) {\n      /* eslint-disable-next-line no-useless-escape */\n      var originRegex = /^(https?\\:\\/\\/)?([^:\\/?#]*(?:\\:[0-9]+)?)/;\n      return originRegex.exec(url)[0];\n    } // Execute the flow type\n\n\n    switch (flowType) {\n      case 'IFRAME':\n        var iframePromise = addPostMessageListener(sdk, options.timeout, oauthParams.state);\n        var iframeEl = oauthUtil.loadFrame(requestUrl);\n        return iframePromise.then(function (res) {\n          return handleOAuthResponse(sdk, oauthParams, res, urls);\n        }).fin(function () {\n          if (document.body.contains(iframeEl)) {\n            iframeEl.parentElement.removeChild(iframeEl);\n          }\n        });\n\n      case 'POPUP':\n        // eslint-disable-line no-case-declarations\n        var popupPromise; // Add listener on postMessage before window creation, so\n        // postMessage isn't triggered before we're listening\n\n        if (oauthParams.responseMode === 'okta_post_message') {\n          if (!sdk.features.isPopupPostMessageSupported()) {\n            return Q.reject(new AuthSdkError('This browser doesn\\'t have full postMessage support'));\n          }\n\n          popupPromise = addPostMessageListener(sdk, options.timeout, oauthParams.state);\n        } // Create the window\n\n\n        var windowOptions = {\n          popupTitle: options.popupTitle\n        };\n        var windowEl = oauthUtil.loadPopup(requestUrl, windowOptions); // Poll until we get a valid hash fragment\n\n        if (oauthParams.responseMode === 'fragment') {\n          var windowOrigin = getOrigin(sdk.idToken.authorize._getLocationHref());\n          var redirectUriOrigin = getOrigin(oauthParams.redirectUri);\n\n          if (windowOrigin !== redirectUriOrigin) {\n            return Q.reject(new AuthSdkError('Using fragment, the redirectUri origin (' + redirectUriOrigin + ') must match the origin of this page (' + windowOrigin + ')'));\n          }\n\n          popupPromise = addFragmentListener(sdk, windowEl, options.timeout);\n        } // Both postMessage and fragment require a poll to see if the popup closed\n\n\n        var popupDeferred = Q.defer();\n        /* eslint-disable-next-line no-case-declarations, no-inner-declarations */\n\n        function hasClosed(win) {\n          if (win.closed) {\n            popupDeferred.reject(new AuthSdkError('Unable to parse OAuth flow response'));\n          }\n        }\n\n        var closePoller = setInterval(function () {\n          hasClosed(windowEl);\n        }, 500); // Proxy the promise results into the deferred\n\n        popupPromise.then(function (res) {\n          popupDeferred.resolve(res);\n        }).fail(function (err) {\n          popupDeferred.reject(err);\n        });\n        return popupDeferred.promise.then(function (res) {\n          return handleOAuthResponse(sdk, oauthParams, res, urls);\n        }).fin(function () {\n          if (!windowEl.closed) {\n            clearInterval(closePoller);\n            windowEl.close();\n          }\n        });\n\n      default:\n        return Q.reject(new AuthSdkError('The full page redirect flow is not supported'));\n    }\n  });\n}\n\nfunction getWithoutPrompt(sdk, oauthOptions, options) {\n  var oauthParams = util.clone(oauthOptions) || {};\n  util.extend(oauthParams, {\n    prompt: 'none',\n    responseMode: 'okta_post_message',\n    display: null\n  });\n  return getToken(sdk, oauthParams, options);\n}\n\nfunction getWithPopup(sdk, oauthOptions, options) {\n  var oauthParams = util.clone(oauthOptions) || {};\n  util.extend(oauthParams, {\n    display: 'popup',\n    responseMode: 'okta_post_message'\n  });\n  return getToken(sdk, oauthParams, options);\n}\n\nfunction prepareOauthParams(sdk, oauthOptions) {\n  // clone and prepare options\n  oauthOptions = util.clone(oauthOptions) || {}; // OKTA-242989: support for grantType will be removed in 3.0 \n\n  if (oauthOptions.grantType === 'authorization_code') {\n    oauthOptions.pkce = true;\n  } // build params using defaults + options\n\n\n  var oauthParams = getDefaultOAuthParams(sdk);\n  util.extend(oauthParams, oauthOptions);\n\n  if (oauthParams.pkce !== true) {\n    return Q.resolve(oauthParams);\n  } // PKCE flow\n\n\n  if (!sdk.features.isPKCESupported()) {\n    return Q.reject(new AuthSdkError('This browser doesn\\'t support PKCE'));\n  } // set default code challenge method, if none provided\n\n\n  if (!oauthParams.codeChallengeMethod) {\n    oauthParams.codeChallengeMethod = PKCE.DEFAULT_CODE_CHALLENGE_METHOD;\n  } // responseType is forced\n\n\n  oauthParams.responseType = 'code';\n  return oauthUtil.getWellKnown(sdk, null).then(function (res) {\n    var methods = res['code_challenge_methods_supported'] || [];\n\n    if (methods.indexOf(oauthParams.codeChallengeMethod) === -1) {\n      throw new AuthSdkError('Invalid code_challenge_method');\n    }\n  }).then(function () {\n    // PKCE authorization_code flow\n    var codeVerifier = PKCE.generateVerifier(oauthParams.codeVerifier); // We will need these values after redirect when we call /token\n\n    var meta = {\n      codeVerifier: codeVerifier,\n      redirectUri: oauthParams.redirectUri\n    };\n    PKCE.saveMeta(sdk, meta);\n    return PKCE.computeChallenge(codeVerifier);\n  }).then(function (codeChallenge) {\n    // Clone/copy the params. Set codeChallenge\n    var clonedParams = util.clone(oauthParams) || {};\n    util.extend(clonedParams, oauthParams, {\n      codeChallenge: codeChallenge\n    });\n    return clonedParams;\n  });\n}\n\nfunction getWithRedirect(sdk, oauthOptions, options) {\n  oauthOptions = util.clone(oauthOptions) || {};\n  return prepareOauthParams(sdk, oauthOptions).then(function (oauthParams) {\n    // Dynamically set the responseMode unless the user has provided one\n    // Server-side flow requires query. Client-side apps usually prefer fragment.\n    if (!oauthOptions.responseMode) {\n      if (oauthParams.responseType.includes('code') && !oauthParams.pkce) {\n        // server-side flows using authorization_code\n        oauthParams.responseMode = 'query';\n      } else {\n        // general case, client-side flow.\n        oauthParams.responseMode = 'fragment';\n      }\n    }\n\n    var urls = oauthUtil.getOAuthUrls(sdk, oauthParams, options);\n    var requestUrl = urls.authorizeUrl + buildAuthorizeParams(oauthParams); // Set session cookie to store the oauthParams\n\n    cookies.set(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME, JSON.stringify({\n      responseType: oauthParams.responseType,\n      state: oauthParams.state,\n      nonce: oauthParams.nonce,\n      scopes: oauthParams.scopes,\n      clientId: oauthParams.clientId,\n      urls: urls,\n      ignoreSignature: oauthParams.ignoreSignature\n    })); // Set nonce cookie for servers to validate nonce in id_token\n\n    cookies.set(config.REDIRECT_NONCE_COOKIE_NAME, oauthParams.nonce); // Set state cookie for servers to validate state\n\n    cookies.set(config.REDIRECT_STATE_COOKIE_NAME, oauthParams.state);\n\n    sdk.token.getWithRedirect._setLocation(requestUrl);\n  });\n}\n\nfunction renewToken(sdk, token) {\n  if (!oauthUtil.isToken(token)) {\n    return Q.reject(new AuthSdkError('Renew must be passed a token with ' + 'an array of scopes and an accessToken or idToken'));\n  }\n\n  var responseType;\n\n  if (sdk.options.pkce) {\n    responseType = 'code';\n  } else if (token.accessToken) {\n    responseType = 'token';\n  } else {\n    responseType = 'id_token';\n  }\n\n  return sdk.token.getWithoutPrompt({\n    responseType: responseType,\n    scopes: token.scopes\n  }, {\n    authorizeUrl: token.authorizeUrl,\n    userinfoUrl: token.userinfoUrl,\n    issuer: token.issuer\n  });\n}\n\nfunction removeHash(sdk) {\n  var nativeHistory = sdk.token.parseFromUrl._getHistory();\n\n  var nativeDoc = sdk.token.parseFromUrl._getDocument();\n\n  var nativeLoc = sdk.token.parseFromUrl._getLocation();\n\n  if (nativeHistory && nativeHistory.replaceState) {\n    nativeHistory.replaceState(null, nativeDoc.title, nativeLoc.pathname + nativeLoc.search);\n  } else {\n    nativeLoc.hash = '';\n  }\n}\n\nfunction parseFromUrl(sdk, url) {\n  var nativeLoc = sdk.token.parseFromUrl._getLocation();\n\n  var hash = nativeLoc.hash;\n\n  if (url) {\n    hash = url.substring(url.indexOf('#'));\n  }\n\n  if (!hash) {\n    return Q.reject(new AuthSdkError('Unable to parse a token from the url'));\n  }\n\n  var oauthParamsCookie = cookies.get(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME);\n\n  if (!oauthParamsCookie) {\n    return Q.reject(new AuthSdkError('Unable to retrieve OAuth redirect params cookie'));\n  }\n\n  try {\n    var oauthParams = JSON.parse(oauthParamsCookie);\n    var urls = oauthParams.urls;\n    delete oauthParams.urls;\n    cookies.delete(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME);\n  } catch (e) {\n    return Q.reject(new AuthSdkError('Unable to parse the ' + config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME + ' cookie: ' + e.message));\n  }\n\n  return Q.resolve(oauthUtil.hashToObject(hash)).then(function (res) {\n    if (!url) {\n      // Remove the hash from the url\n      removeHash(sdk);\n    }\n\n    return handleOAuthResponse(sdk, oauthParams, res, urls);\n  });\n}\n\nfunction getUserInfo(sdk, accessTokenObject) {\n  if (!accessTokenObject || !oauthUtil.isToken(accessTokenObject) && !accessTokenObject.accessToken && !accessTokenObject.userinfoUrl) {\n    return Q.reject(new AuthSdkError('getUserInfo requires an access token object'));\n  }\n\n  return http.httpRequest(sdk, {\n    url: accessTokenObject.userinfoUrl,\n    method: 'GET',\n    accessToken: accessTokenObject.accessToken\n  }).fail(function (err) {\n    if (err.xhr && (err.xhr.status === 401 || err.xhr.status === 403)) {\n      var authenticateHeader;\n\n      if (err.xhr.headers && util.isFunction(err.xhr.headers.get) && err.xhr.headers.get('WWW-Authenticate')) {\n        authenticateHeader = err.xhr.headers.get('WWW-Authenticate');\n      } else if (util.isFunction(err.xhr.getResponseHeader)) {\n        authenticateHeader = err.xhr.getResponseHeader('WWW-Authenticate');\n      }\n\n      if (authenticateHeader) {\n        var errorMatches = authenticateHeader.match(/error=\"(.*?)\"/) || [];\n        var errorDescriptionMatches = authenticateHeader.match(/error_description=\"(.*?)\"/) || [];\n        var error = errorMatches[1];\n        var errorDescription = errorDescriptionMatches[1];\n\n        if (error && errorDescription) {\n          err = new OAuthError(error, errorDescription);\n        }\n      }\n    }\n\n    throw err;\n  });\n}\n\nmodule.exports = {\n  getToken: getToken,\n  getWithoutPrompt: getWithoutPrompt,\n  getWithPopup: getWithPopup,\n  getWithRedirect: getWithRedirect,\n  parseFromUrl: parseFromUrl,\n  decodeToken: decodeToken,\n  renewToken: renewToken,\n  getUserInfo: getUserInfo,\n  verifyToken: verifyToken,\n  handleOAuthResponse: handleOAuthResponse,\n  prepareOauthParams: prepareOauthParams\n};","map":{"version":3,"sources":["/app/node_modules/@okta/okta-auth-js/lib/token.js"],"names":["http","require","util","oauthUtil","Q","sdkCrypto","AuthSdkError","OAuthError","config","cookies","storage","PKCE","decodeToken","token","jwt","split","decodedToken","header","JSON","parse","base64UrlToString","payload","signature","e","verifyToken","sdk","validationParams","then","idToken","validationOptions","clientId","options","issuer","url","ignoreSignature","extend","validateClaims","features","isTokenVerifySupported","getKey","kid","key","valid","addPostMessageListener","timeout","state","deferred","defer","responseHandler","data","origin","reject","resolve","addListener","window","promise","fin","removeListener","addFragmentListener","windowEl","hashChangeHandler","location","hash","hashToObject","closed","setTimeout","err","exchangeCodeForToken","oauthParams","authorizationCode","urls","meta","loadMeta","getTokenParams","codeVerifier","redirectUri","getToken","res","validateResponse","clearMeta","handleOAuthResponse","responseType","scopes","clone","tokenDict","accessToken","expiresAt","Number","Math","floor","Date","now","tokenType","authorizeUrl","userinfoUrl","decode","claims","exp","nonce","undefined","Array","isArray","validateTokenTypes","filter","indexOf","forEach","map","item","getDefaultOAuthParams","pkce","href","responseMode","generateState","generateNonce","convertOAuthParamsToQueryParams","isString","oauthQueryParams","removeNils","codeChallenge","codeChallengeMethod","display","idp","idpScope","loginHint","maxAge","prompt","sessionToken","mayBeArray","join","scope","buildAuthorizeParams","toQueryParams","oauthOptions","prepareOauthParams","sessionTokenOverrides","idpOverrides","requestUrl","endpoint","getOAuthUrls","tokenUrl","flowType","getOrigin","originRegex","exec","iframePromise","iframeEl","loadFrame","document","body","contains","parentElement","removeChild","popupPromise","isPopupPostMessageSupported","windowOptions","popupTitle","loadPopup","windowOrigin","authorize","_getLocationHref","redirectUriOrigin","popupDeferred","hasClosed","win","closePoller","setInterval","fail","clearInterval","close","getWithoutPrompt","getWithPopup","grantType","isPKCESupported","DEFAULT_CODE_CHALLENGE_METHOD","getWellKnown","methods","generateVerifier","saveMeta","computeChallenge","clonedParams","getWithRedirect","includes","set","REDIRECT_OAUTH_PARAMS_COOKIE_NAME","stringify","REDIRECT_NONCE_COOKIE_NAME","REDIRECT_STATE_COOKIE_NAME","_setLocation","renewToken","isToken","removeHash","nativeHistory","parseFromUrl","_getHistory","nativeDoc","_getDocument","nativeLoc","_getLocation","replaceState","title","pathname","search","substring","oauthParamsCookie","get","delete","message","getUserInfo","accessTokenObject","httpRequest","method","xhr","status","authenticateHeader","headers","isFunction","getResponseHeader","errorMatches","match","errorDescriptionMatches","error","errorDescription","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n *\n */\n\n/* eslint-disable complexity, max-statements */\nvar http          = require('./http');\nvar util          = require('./util');\nvar oauthUtil     = require('./oauthUtil');\nvar Q             = require('q');\nvar sdkCrypto     = require('./crypto');\nvar AuthSdkError  = require('./errors/AuthSdkError');\nvar OAuthError    = require('./errors/OAuthError');\nvar config        = require('./config');\nvar cookies       = require('./browser/browserStorage').storage;\nvar PKCE          = require('./pkce');\n\nfunction decodeToken(token) {\n  var jwt = token.split('.');\n  var decodedToken;\n\n  try {\n    decodedToken = {\n      header: JSON.parse(util.base64UrlToString(jwt[0])),\n      payload: JSON.parse(util.base64UrlToString(jwt[1])),\n      signature: jwt[2]\n    };\n  } catch(e) {\n    throw new AuthSdkError('Malformed token');\n  }\n\n  return decodedToken;\n}\n\nfunction verifyToken(sdk, token, validationParams) {\n  return new Q()\n  .then(function() {\n    if (!token || !token.idToken) {\n      throw new AuthSdkError('Only idTokens may be verified');\n    }\n\n    var jwt = decodeToken(token.idToken);\n\n    var validationOptions = {\n      clientId: sdk.options.clientId,\n      issuer: sdk.options.issuer || sdk.options.url,\n      ignoreSignature: sdk.options.ignoreSignature\n    };\n\n    util.extend(validationOptions, validationParams);\n\n    // Standard claim validation\n    oauthUtil.validateClaims(sdk, jwt.payload, validationOptions);\n\n    // If the browser doesn't support native crypto or we choose not\n    // to verify the signature, bail early\n    if (validationOptions.ignoreSignature == true || !sdk.features.isTokenVerifySupported()) {\n      return token;\n    }\n\n    return oauthUtil.getKey(sdk, token.issuer, jwt.header.kid)\n    .then(function(key) {\n      return sdkCrypto.verifyToken(token.idToken, key);\n    })\n    .then(function(valid) {\n      if (!valid) {\n        throw new AuthSdkError('The token signature is not valid');\n      }\n      return token;\n    });\n  });\n}\n\nfunction addPostMessageListener(sdk, timeout, state) {\n  var deferred = Q.defer();\n\n  function responseHandler(e) {\n    if (!e.data || e.data.state !== state) {\n      // A message not meant for us\n      return;\n    }\n\n    // Configuration mismatch between saved token and current app instance\n    // This may happen if apps with different issuers are running on the same host url\n    // If they share the same storage key, they may read and write tokens in the same location.\n    // Common when developing against http://localhost\n    if (e.origin !== sdk.options.url) {\n      return deferred.reject(new AuthSdkError('The request does not match client configuration'));\n    }\n\n    deferred.resolve(e.data);\n  }\n\n  oauthUtil.addListener(window, 'message', responseHandler);\n\n  return deferred.promise.timeout(timeout || 120000, new AuthSdkError('OAuth flow timed out'))\n    .fin(function() {\n      oauthUtil.removeListener(window, 'message', responseHandler);\n    });\n}\n\nfunction addFragmentListener(sdk, windowEl, timeout) {\n  var deferred = Q.defer();\n\n  function hashChangeHandler() {\n    /*\n      We are only able to access window.location.hash on a window\n      that has the same domain. A try/catch is necessary because\n      there's no other way to determine that the popup is in\n      another domain. When we try to access a window on another\n      domain, an error is thrown.\n    */\n    try {\n      if (windowEl &&\n          windowEl.location &&\n          windowEl.location.hash) {\n        deferred.resolve(oauthUtil.hashToObject(windowEl.location.hash));\n      } else if (windowEl && !windowEl.closed) {\n        setTimeout(hashChangeHandler, 500);\n      }\n    } catch (err) {\n      setTimeout(hashChangeHandler, 500);\n    }\n  }\n\n  hashChangeHandler();\n\n  return deferred.promise.timeout(timeout || 120000, new AuthSdkError('OAuth flow timed out'));\n}\n\nfunction exchangeCodeForToken(sdk, oauthParams, authorizationCode, urls) {\n  // PKCE authorization_code flow\n  // Retrieve saved values and build oauthParams for call to /token\n  var meta = PKCE.loadMeta(sdk);\n  var getTokenParams = {\n    clientId: oauthParams.clientId,\n    authorizationCode: authorizationCode,\n    codeVerifier: meta.codeVerifier,\n    redirectUri: meta.redirectUri\n  };\n  return PKCE.getToken(sdk, getTokenParams, urls)\n  .then(function(res) {\n    validateResponse(res, getTokenParams);\n    return res;\n  })\n  .fin(function() {\n    PKCE.clearMeta(sdk);\n  });\n}\n\nfunction validateResponse(res, oauthParams) {\n  if (res['error'] || res['error_description']) {\n    throw new OAuthError(res['error'], res['error_description']);\n  }\n\n  if (res.state !== oauthParams.state) {\n    throw new AuthSdkError('OAuth flow response state doesn\\'t match request state');\n  }\n}\n\nfunction handleOAuthResponse(sdk, oauthParams, res, urls) {\n  urls = urls || {};\n\n  var responseType = oauthParams.responseType;\n  var scopes = util.clone(oauthParams.scopes);\n  var clientId = oauthParams.clientId || sdk.options.clientId;\n\n  return new Q()\n  .then(function() {\n    validateResponse(res, oauthParams);\n\n    // We do not support \"hybrid\" scenarios where the response includes both a code and a token.\n    // If the response contains a code it is used immediately to obtain new tokens.\n    if (res['code']) {\n      responseType = ['token', 'id_token']; // what we expect the code to provide us\n      return exchangeCodeForToken(sdk, oauthParams, res['code'], urls);\n    }\n    return res;\n  }).then(function(res) {\n    var tokenDict = {};\n\n    if (res['access_token']) {\n      tokenDict['token'] = {\n        accessToken: res['access_token'],\n        expiresAt: Number(res['expires_in']) + Math.floor(Date.now()/1000),\n        tokenType: res['token_type'],\n        scopes: scopes,\n        authorizeUrl: urls.authorizeUrl,\n        userinfoUrl: urls.userinfoUrl\n      };\n    }\n\n    if (res['id_token']) {\n      var jwt = sdk.token.decode(res['id_token']);\n\n      var idToken = {\n        idToken: res['id_token'],\n        claims: jwt.payload,\n        expiresAt: jwt.payload.exp,\n        scopes: scopes,\n        authorizeUrl: urls.authorizeUrl,\n        issuer: urls.issuer,\n        clientId: clientId\n      };\n\n      var validationParams = {\n        clientId: clientId,\n        issuer: urls.issuer,\n        nonce: oauthParams.nonce\n      };\n\n      if (oauthParams.ignoreSignature !== undefined) {\n        validationParams.ignoreSignature = oauthParams.ignoreSignature;\n      }\n\n      return verifyToken(sdk, idToken, validationParams)\n      .then(function() {\n        tokenDict['id_token'] = idToken;\n        return tokenDict;\n      });\n    }\n\n    return tokenDict;\n  })\n  .then(function(tokenDict) {\n    if (!Array.isArray(responseType)) {\n      return tokenDict[responseType];\n    }\n\n    // Validate response against tokenTypes\n    var validateTokenTypes =  ['token', 'id_token'];\n    validateTokenTypes.filter(function(key) {\n      return (responseType.indexOf(key) !== -1);\n    }).forEach(function(key) {\n      if (!tokenDict[key]) {\n        throw new AuthSdkError('Unable to parse OAuth flow response: ' + key + ' was not returned.');\n      }     \n    });\n\n    // Create token array in the order of the responseType array\n    return responseType.map(function(item) {\n      return tokenDict[item];\n    });\n  });\n}\n\nfunction getDefaultOAuthParams(sdk) {\n  return {\n    pkce: sdk.options.pkce || false,\n    clientId: sdk.options.clientId,\n    redirectUri: sdk.options.redirectUri || window.location.href,\n    responseType: 'id_token',\n    responseMode: 'okta_post_message',\n    state: oauthUtil.generateState(),\n    nonce: oauthUtil.generateNonce(),\n    scopes: ['openid', 'email'],\n    ignoreSignature: sdk.options.ignoreSignature\n  };\n}\n\nfunction convertOAuthParamsToQueryParams(oauthParams) {\n  // Quick validation\n  if (!oauthParams.clientId) {\n    throw new AuthSdkError('A clientId must be specified in the OktaAuth constructor to get a token');\n  }\n\n  if (util.isString(oauthParams.responseType) && oauthParams.responseType.indexOf(' ') !== -1) {\n    throw new AuthSdkError('Multiple OAuth responseTypes must be defined as an array');\n  }\n\n  // Convert our params to their actual OAuth equivalents\n  var oauthQueryParams = util.removeNils({\n    'client_id': oauthParams.clientId,\n    'code_challenge': oauthParams.codeChallenge,\n    'code_challenge_method': oauthParams.codeChallengeMethod,\n    'display': oauthParams.display,\n    'idp': oauthParams.idp,\n    'idp_scope': oauthParams.idpScope,\n    'login_hint': oauthParams.loginHint,\n    'max_age': oauthParams.maxAge,\n    'nonce': oauthParams.nonce,\n    'prompt': oauthParams.prompt,\n    'redirect_uri': oauthParams.redirectUri,\n    'response_mode': oauthParams.responseMode,\n    'response_type': oauthParams.responseType,\n    'sessionToken': oauthParams.sessionToken,\n    'state': oauthParams.state,\n  });\n\n  ['idp_scope', 'response_type'].forEach( function( mayBeArray ) { \n    if (Array.isArray(oauthQueryParams[mayBeArray])) {\n      oauthQueryParams[mayBeArray] = oauthQueryParams[mayBeArray].join(' ');\n    }\n  });\n\n  if (oauthParams.responseType.indexOf('id_token') !== -1 &&\n      oauthParams.scopes.indexOf('openid') === -1) {\n    throw new AuthSdkError('openid scope must be specified in the scopes argument when requesting an id_token');\n  } else {\n    oauthQueryParams.scope = oauthParams.scopes.join(' ');\n  }\n\n  return oauthQueryParams;\n}\n\nfunction buildAuthorizeParams(oauthParams) {\n  var oauthQueryParams = convertOAuthParamsToQueryParams(oauthParams);\n  return util.toQueryParams(oauthQueryParams);\n}\n\n/*\n * Retrieve an idToken from an Okta or a third party idp\n *\n * Two main flows:\n *\n *  1) Exchange a sessionToken for a token\n *\n *    Required:\n *      clientId: passed via the OktaAuth constructor or into getToken\n *      sessionToken: 'yourtoken'\n *\n *    Optional:\n *      redirectUri: defaults to window.location.href\n *      scopes: defaults to ['openid', 'email']\n *\n *    Forced:\n *      prompt: 'none'\n *      responseMode: 'okta_post_message'\n *      display: undefined\n *\n *  2) Get a token from an idp\n *\n *    Required:\n *      clientId: passed via the OktaAuth constructor or into getToken\n *\n *    Optional:\n *      redirectUri: defaults to window.location.href\n *      scopes: defaults to ['openid', 'email']\n *      idp: defaults to Okta as an idp\n *      prompt: no default. Pass 'none' to throw an error if user is not signed in\n *\n *    Forced:\n *      display: 'popup'\n *\n *  Only common optional params shown. Any OAuth parameters not explicitly forced are available to override\n *\n * @param {Object} oauthOptions\n * @param {String} [oauthOptions.clientId] ID of this client\n * @param {String} [oauthOptions.redirectUri] URI that the iframe or popup will go to once authenticated\n * @param {String[]} [oauthOptions.scopes] OAuth 2.0 scopes to request (openid must be specified)\n * @param {String} [oauthOptions.idp] ID of an external IdP to use for user authentication\n * @param {String} [oauthOptions.sessionToken] Bootstrap Session Token returned by the Okta Authentication API\n * @param {String} [oauthOptions.prompt] Determines whether the Okta login will be displayed on failure.\n *                                       Use 'none' to prevent this behavior\n *\n * @param {Object} options\n * @param {Integer} [options.timeout] Time in ms before the flow is automatically terminated. Defaults to 120000\n * @param {String} [options.popupTitle] Title dispayed in the popup.\n *                                      Defaults to 'External Identity Provider User Authentication'\n */\nfunction getToken(sdk, oauthOptions, options) {\n  oauthOptions = oauthOptions || {};\n  options = options || {};\n\n  return prepareOauthParams(sdk, oauthOptions)\n  .then(function(oauthParams) {\n\n    // Start overriding any options that don't make sense\n    var sessionTokenOverrides = {\n      prompt: 'none',\n      responseMode: 'okta_post_message',\n      display: null\n    };\n\n    var idpOverrides = {\n      display: 'popup'\n    };\n\n    if (oauthOptions.sessionToken) {\n      util.extend(oauthParams, sessionTokenOverrides);\n    } else if (oauthOptions.idp) {\n      util.extend(oauthParams, idpOverrides);\n    }\n\n    // Use the query params to build the authorize url\n    var requestUrl,\n        endpoint,\n        urls;\n    try {\n      // Get authorizeUrl and issuer\n      urls = oauthUtil.getOAuthUrls(sdk, oauthParams, options);\n      endpoint = oauthOptions.codeVerifier ? urls.tokenUrl : urls.authorizeUrl;\n      requestUrl = endpoint + buildAuthorizeParams(oauthParams);\n    } catch (e) {\n      return Q.reject(e);\n    }\n\n    // Determine the flow type\n    var flowType;\n    if (oauthParams.sessionToken || oauthParams.display === null) {\n      flowType = 'IFRAME';\n    } else if (oauthParams.display === 'popup') {\n      flowType = 'POPUP';\n    } else {\n      flowType = 'IMPLICIT';\n    }\n\n    function getOrigin(url) {\n      /* eslint-disable-next-line no-useless-escape */\n      var originRegex = /^(https?\\:\\/\\/)?([^:\\/?#]*(?:\\:[0-9]+)?)/;\n      return originRegex.exec(url)[0];\n    }\n\n    // Execute the flow type\n    switch (flowType) {\n      case 'IFRAME':\n        var iframePromise = addPostMessageListener(sdk, options.timeout, oauthParams.state);\n        var iframeEl = oauthUtil.loadFrame(requestUrl);\n        return iframePromise\n          .then(function(res) {\n            return handleOAuthResponse(sdk, oauthParams, res, urls);\n          })\n          .fin(function() {\n            if (document.body.contains(iframeEl)) {\n              iframeEl.parentElement.removeChild(iframeEl);\n            }\n          });\n\n      case 'POPUP': // eslint-disable-line no-case-declarations\n        var popupPromise;\n\n        // Add listener on postMessage before window creation, so\n        // postMessage isn't triggered before we're listening\n        if (oauthParams.responseMode === 'okta_post_message') {\n          if (!sdk.features.isPopupPostMessageSupported()) {\n            return Q.reject(new AuthSdkError('This browser doesn\\'t have full postMessage support'));\n          }\n          popupPromise = addPostMessageListener(sdk, options.timeout, oauthParams.state);\n        }\n\n        // Create the window\n        var windowOptions = {\n          popupTitle: options.popupTitle\n        };\n        var windowEl = oauthUtil.loadPopup(requestUrl, windowOptions);\n\n        // Poll until we get a valid hash fragment\n        if (oauthParams.responseMode === 'fragment') {\n          var windowOrigin = getOrigin(sdk.idToken.authorize._getLocationHref());\n          var redirectUriOrigin = getOrigin(oauthParams.redirectUri);\n          if (windowOrigin !== redirectUriOrigin) {\n            return Q.reject(new AuthSdkError('Using fragment, the redirectUri origin (' + redirectUriOrigin +\n              ') must match the origin of this page (' + windowOrigin + ')'));\n          }\n          popupPromise = addFragmentListener(sdk, windowEl, options.timeout);\n        }\n\n        // Both postMessage and fragment require a poll to see if the popup closed\n        var popupDeferred = Q.defer();\n        /* eslint-disable-next-line no-case-declarations, no-inner-declarations */\n        function hasClosed(win) {\n          if (win.closed) {\n            popupDeferred.reject(new AuthSdkError('Unable to parse OAuth flow response'));\n          }\n        }\n        var closePoller = setInterval(function() {\n          hasClosed(windowEl);\n        }, 500);\n\n        // Proxy the promise results into the deferred\n        popupPromise\n        .then(function(res) {\n          popupDeferred.resolve(res);\n        })\n        .fail(function(err) {\n          popupDeferred.reject(err);\n        });\n\n        return popupDeferred.promise\n          .then(function(res) {\n            return handleOAuthResponse(sdk, oauthParams, res, urls);\n          })\n          .fin(function() {\n            if (!windowEl.closed) {\n              clearInterval(closePoller);\n              windowEl.close();\n            }\n          });\n\n      default:\n        return Q.reject(new AuthSdkError('The full page redirect flow is not supported'));\n    }\n  });\n}\n\nfunction getWithoutPrompt(sdk, oauthOptions, options) {\n  var oauthParams = util.clone(oauthOptions) || {};\n  util.extend(oauthParams, {\n    prompt: 'none',\n    responseMode: 'okta_post_message',\n    display: null\n  });\n  return getToken(sdk, oauthParams, options);\n}\n\nfunction getWithPopup(sdk, oauthOptions, options) {\n  var oauthParams = util.clone(oauthOptions) || {};\n  util.extend(oauthParams, {\n    display: 'popup',\n    responseMode: 'okta_post_message'\n  });\n  return getToken(sdk, oauthParams, options);\n}\n\nfunction prepareOauthParams(sdk, oauthOptions) {\n  // clone and prepare options\n  oauthOptions = util.clone(oauthOptions) || {};\n\n  // OKTA-242989: support for grantType will be removed in 3.0 \n  if (oauthOptions.grantType === 'authorization_code') {\n    oauthOptions.pkce = true;\n  }\n\n  // build params using defaults + options\n  var oauthParams = getDefaultOAuthParams(sdk);\n  util.extend(oauthParams, oauthOptions);\n\n  if (oauthParams.pkce !== true) {\n    return Q.resolve(oauthParams);\n  }\n\n  // PKCE flow\n  if (!sdk.features.isPKCESupported()) {\n    return Q.reject(new AuthSdkError('This browser doesn\\'t support PKCE'));\n  }\n\n  // set default code challenge method, if none provided\n  if (!oauthParams.codeChallengeMethod) {\n    oauthParams.codeChallengeMethod = PKCE.DEFAULT_CODE_CHALLENGE_METHOD;\n  }\n\n  // responseType is forced\n  oauthParams.responseType = 'code';\n\n  return oauthUtil.getWellKnown(sdk, null)\n    .then(function(res) {\n      var methods = res['code_challenge_methods_supported'] || [];\n      if (methods.indexOf(oauthParams.codeChallengeMethod) === -1) {\n        throw new AuthSdkError('Invalid code_challenge_method');\n      }\n    })\n    .then(function() {\n      // PKCE authorization_code flow\n      var codeVerifier = PKCE.generateVerifier(oauthParams.codeVerifier);\n\n      // We will need these values after redirect when we call /token\n      var meta = {\n        codeVerifier: codeVerifier,\n        redirectUri: oauthParams.redirectUri\n      };\n      PKCE.saveMeta(sdk, meta);\n\n      return PKCE.computeChallenge(codeVerifier);\n    })\n    .then(function(codeChallenge) {\n\n      // Clone/copy the params. Set codeChallenge\n      var clonedParams = util.clone(oauthParams) || {};\n      util.extend(clonedParams, oauthParams, {\n        codeChallenge: codeChallenge,\n      });\n      return clonedParams;\n    });\n}\n\nfunction getWithRedirect(sdk, oauthOptions, options) {\n  oauthOptions = util.clone(oauthOptions) || {};\n\n  return prepareOauthParams(sdk, oauthOptions)\n    .then(function(oauthParams) {\n\n      // Dynamically set the responseMode unless the user has provided one\n      // Server-side flow requires query. Client-side apps usually prefer fragment.\n      if (!oauthOptions.responseMode) {\n        if (oauthParams.responseType.includes('code') && !oauthParams.pkce) {\n          // server-side flows using authorization_code\n          oauthParams.responseMode = 'query';\n        } else {\n          // general case, client-side flow.\n          oauthParams.responseMode = 'fragment';\n        }\n      }\n\n      var urls = oauthUtil.getOAuthUrls(sdk, oauthParams, options);\n      var requestUrl = urls.authorizeUrl + buildAuthorizeParams(oauthParams);\n\n      // Set session cookie to store the oauthParams\n      cookies.set(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME, JSON.stringify({\n        responseType: oauthParams.responseType,\n        state: oauthParams.state,\n        nonce: oauthParams.nonce,\n        scopes: oauthParams.scopes,\n        clientId: oauthParams.clientId,\n        urls: urls,\n        ignoreSignature: oauthParams.ignoreSignature\n      }));\n\n      // Set nonce cookie for servers to validate nonce in id_token\n      cookies.set(config.REDIRECT_NONCE_COOKIE_NAME, oauthParams.nonce);\n\n      // Set state cookie for servers to validate state\n      cookies.set(config.REDIRECT_STATE_COOKIE_NAME, oauthParams.state);\n\n      sdk.token.getWithRedirect._setLocation(requestUrl);\n    });\n}\n\nfunction renewToken(sdk, token) {\n  if (!oauthUtil.isToken(token)) {\n    return Q.reject(new AuthSdkError('Renew must be passed a token with ' +\n      'an array of scopes and an accessToken or idToken'));\n  }\n\n  var responseType;\n  if (sdk.options.pkce) {\n    responseType = 'code';\n  } else if (token.accessToken) {\n    responseType = 'token';\n  } else {\n    responseType = 'id_token';\n  }\n\n  return sdk.token.getWithoutPrompt({\n    responseType: responseType,\n    scopes: token.scopes\n  }, {\n    authorizeUrl: token.authorizeUrl,\n    userinfoUrl: token.userinfoUrl,\n    issuer: token.issuer\n  });\n}\n\nfunction removeHash(sdk) {\n  var nativeHistory = sdk.token.parseFromUrl._getHistory();\n  var nativeDoc = sdk.token.parseFromUrl._getDocument();\n  var nativeLoc = sdk.token.parseFromUrl._getLocation();\n  if (nativeHistory && nativeHistory.replaceState) {\n    nativeHistory.replaceState(null, nativeDoc.title, nativeLoc.pathname + nativeLoc.search);\n  } else {\n    nativeLoc.hash = '';\n  }\n}\n\nfunction parseFromUrl(sdk, url) {\n  var nativeLoc = sdk.token.parseFromUrl._getLocation();\n  var hash = nativeLoc.hash;\n  if (url) {\n    hash = url.substring(url.indexOf('#'));\n  }\n\n  if (!hash) {\n    return Q.reject(new AuthSdkError('Unable to parse a token from the url'));\n  }\n\n  var oauthParamsCookie = cookies.get(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME);\n  if (!oauthParamsCookie) {\n    return Q.reject(new AuthSdkError('Unable to retrieve OAuth redirect params cookie'));\n  }\n\n  try {\n    var oauthParams = JSON.parse(oauthParamsCookie);\n    var urls = oauthParams.urls;\n    delete oauthParams.urls;\n    cookies.delete(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME);\n  } catch(e) {\n    return Q.reject(new AuthSdkError('Unable to parse the ' +\n      config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME + ' cookie: ' + e.message));\n  }\n\n  return Q.resolve(oauthUtil.hashToObject(hash))\n    .then(function(res) {\n      if (!url) {\n        // Remove the hash from the url\n        removeHash(sdk);\n      }\n      return handleOAuthResponse(sdk, oauthParams, res, urls);\n    });\n}\n\nfunction getUserInfo(sdk, accessTokenObject) {\n  if (!accessTokenObject ||\n      (!oauthUtil.isToken(accessTokenObject) && !accessTokenObject.accessToken && !accessTokenObject.userinfoUrl)) {\n    return Q.reject(new AuthSdkError('getUserInfo requires an access token object'));\n  }\n  return http.httpRequest(sdk, {\n    url: accessTokenObject.userinfoUrl,\n    method: 'GET',\n    accessToken: accessTokenObject.accessToken\n  })\n  .fail(function(err) {\n    if (err.xhr && (err.xhr.status === 401 || err.xhr.status === 403)) {\n      var authenticateHeader;\n      if (err.xhr.headers && util.isFunction(err.xhr.headers.get) && err.xhr.headers.get('WWW-Authenticate')) {\n        authenticateHeader = err.xhr.headers.get('WWW-Authenticate');\n      } else if (util.isFunction(err.xhr.getResponseHeader)) {\n        authenticateHeader = err.xhr.getResponseHeader('WWW-Authenticate');\n      }\n      if (authenticateHeader) {\n        var errorMatches = authenticateHeader.match(/error=\"(.*?)\"/) || [];\n        var errorDescriptionMatches = authenticateHeader.match(/error_description=\"(.*?)\"/) || [];\n        var error = errorMatches[1];\n        var errorDescription = errorDescriptionMatches[1];\n        if (error && errorDescription) {\n          err = new OAuthError(error, errorDescription);\n        }\n      }\n    }\n    throw err;\n  });\n}\n\nmodule.exports = {\n  getToken: getToken,\n  getWithoutPrompt: getWithoutPrompt,\n  getWithPopup: getWithPopup,\n  getWithRedirect: getWithRedirect,\n  parseFromUrl: parseFromUrl,\n  decodeToken: decodeToken,\n  renewToken: renewToken,\n  getUserInfo: getUserInfo,\n  verifyToken: verifyToken,\n  handleOAuthResponse: handleOAuthResponse,\n  prepareOauthParams: prepareOauthParams\n};\n"]},"metadata":{},"sourceType":"script"}