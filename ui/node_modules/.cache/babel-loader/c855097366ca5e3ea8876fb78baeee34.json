{"ast":null,"code":"/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n *\n */\n\n/* eslint complexity:[0,8] max-statements:[0,21] */\nvar util = require('./util');\n\nvar AuthSdkError = require('./errors/AuthSdkError');\n\nvar storageUtil = require('./browser/browserStorage');\n\nvar Q = require('q');\n\nvar Emitter = require('tiny-emitter');\n\nvar config = require('./config');\n\nvar storageBuilder = require('./storageBuilder');\n\nvar SdkClock = require('./clock');\n\nvar DEFAULT_OPTIONS = {\n  autoRenew: true,\n  storage: 'localStorage',\n  expireEarlySeconds: 30\n};\n\nfunction getExpireTime(tokenMgmtRef, token) {\n  var expireTime = token.expiresAt - tokenMgmtRef.options.expireEarlySeconds;\n  return expireTime;\n}\n\nfunction hasExpired(tokenMgmtRef, token) {\n  var expireTime = getExpireTime(tokenMgmtRef, token);\n  return expireTime <= tokenMgmtRef.clock.now();\n}\n\nfunction emitExpired(tokenMgmtRef, key, token) {\n  tokenMgmtRef.emitter.emit('expired', key, token);\n}\n\nfunction emitError(tokenMgmtRef, error) {\n  tokenMgmtRef.emitter.emit('error', error);\n}\n\nfunction clearExpireEventTimeout(tokenMgmtRef, key) {\n  clearTimeout(tokenMgmtRef.expireTimeouts[key]);\n  delete tokenMgmtRef.expireTimeouts[key]; // Remove the renew promise (if it exists)\n\n  delete tokenMgmtRef.renewPromise[key];\n}\n\nfunction clearExpireEventTimeoutAll(tokenMgmtRef) {\n  var expireTimeouts = tokenMgmtRef.expireTimeouts;\n\n  for (var key in expireTimeouts) {\n    if (!expireTimeouts.hasOwnProperty(key)) {\n      continue;\n    }\n\n    clearExpireEventTimeout(tokenMgmtRef, key);\n  }\n}\n\nfunction setExpireEventTimeout(sdk, tokenMgmtRef, key, token) {\n  var expireTime = getExpireTime(tokenMgmtRef, token);\n  var expireEventWait = Math.max(expireTime - tokenMgmtRef.clock.now(), 0) * 1000; // Clear any existing timeout\n\n  clearExpireEventTimeout(tokenMgmtRef, key);\n  var expireEventTimeout = setTimeout(function () {\n    emitExpired(tokenMgmtRef, key, token);\n  }, expireEventWait); // Add a new timeout\n\n  tokenMgmtRef.expireTimeouts[key] = expireEventTimeout;\n}\n\nfunction setExpireEventTimeoutAll(sdk, tokenMgmtRef, storage) {\n  try {\n    var tokenStorage = storage.getStorage();\n  } catch (e) {\n    // Any errors thrown on instantiation will not be caught,\n    // because there are no listeners yet\n    emitError(tokenMgmtRef, e);\n    return;\n  }\n\n  for (var key in tokenStorage) {\n    if (!tokenStorage.hasOwnProperty(key)) {\n      continue;\n    }\n\n    var token = tokenStorage[key];\n    setExpireEventTimeout(sdk, tokenMgmtRef, key, token);\n  }\n}\n\nfunction add(sdk, tokenMgmtRef, storage, key, token) {\n  var tokenStorage = storage.getStorage();\n\n  if (!util.isObject(token) || !token.scopes || !token.expiresAt && token.expiresAt !== 0 || !token.idToken && !token.accessToken) {\n    throw new AuthSdkError('Token must be an Object with scopes, expiresAt, and an idToken or accessToken properties');\n  }\n\n  tokenStorage[key] = token;\n  storage.setStorage(tokenStorage);\n  setExpireEventTimeout(sdk, tokenMgmtRef, key, token);\n}\n\nfunction get(storage, key) {\n  var tokenStorage = storage.getStorage();\n  return tokenStorage[key];\n}\n\nfunction getAsync(sdk, tokenMgmtRef, storage, key) {\n  return Q.Promise(function (resolve) {\n    var token = get(storage, key);\n\n    if (!token || !hasExpired(tokenMgmtRef, token)) {\n      return resolve(token);\n    }\n\n    var tokenPromise = tokenMgmtRef.options.autoRenew ? renew(sdk, tokenMgmtRef, storage, key) : remove(tokenMgmtRef, storage, key);\n    return resolve(tokenPromise);\n  });\n}\n\nfunction remove(tokenMgmtRef, storage, key) {\n  // Clear any listener for this token\n  clearExpireEventTimeout(tokenMgmtRef, key); // Remove it from storage\n\n  var tokenStorage = storage.getStorage();\n  delete tokenStorage[key];\n  storage.setStorage(tokenStorage);\n}\n\nfunction renew(sdk, tokenMgmtRef, storage, key) {\n  // Multiple callers may receive the same promise. They will all resolve or reject from the same request.\n  var existingPromise = tokenMgmtRef.renewPromise[key];\n\n  if (existingPromise) {\n    return existingPromise;\n  }\n\n  try {\n    var token = get(storage, key);\n\n    if (!token) {\n      throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n    }\n  } catch (e) {\n    return Q.reject(e);\n  } // Remove existing autoRenew timeout for this key\n\n\n  clearExpireEventTimeout(tokenMgmtRef, key); // Store the renew promise state, to avoid renewing again\n\n  tokenMgmtRef.renewPromise[key] = sdk.token.renew(token).then(function (freshTokens) {\n    var freshToken = freshTokens; // With PKCE flow we will receive multiple tokens. Find the one we are looking for\n\n    if (freshTokens instanceof Array) {\n      freshToken = freshTokens.find(function (freshToken) {\n        return freshToken.idToken && token.idToken || freshToken.accessToken && token.accessToken;\n      });\n    }\n\n    var oldToken = get(storage, key);\n\n    if (!oldToken) {\n      // It is possible to enter a state where the tokens have been cleared\n      // after a renewal request was triggered. To ensure we do not store a\n      // renewed token, we verify the promise key doesn't exist and return.\n      return;\n    }\n\n    add(sdk, tokenMgmtRef, storage, key, freshToken);\n    tokenMgmtRef.emitter.emit('renewed', key, freshToken, oldToken);\n    return freshToken;\n  }).catch(function (err) {\n    if (err.name === 'OAuthError' || err.name === 'AuthSdkError') {\n      remove(tokenMgmtRef, storage, key);\n      emitError(tokenMgmtRef, err);\n    }\n\n    throw err;\n  }).finally(function () {\n    // Remove existing promise key\n    delete tokenMgmtRef.renewPromise[key];\n  });\n  return tokenMgmtRef.renewPromise[key];\n}\n\nfunction clear(tokenMgmtRef, storage) {\n  clearExpireEventTimeoutAll(tokenMgmtRef);\n  storage.clearStorage();\n}\n\nfunction TokenManager(sdk, options) {\n  options = util.extend({}, DEFAULT_OPTIONS, util.removeNils(options));\n\n  if (options.storage === 'localStorage' && !storageUtil.browserHasLocalStorage()) {\n    util.warn('This browser doesn\\'t support localStorage. Switching to sessionStorage.');\n    options.storage = 'sessionStorage';\n  }\n\n  if (options.storage === 'sessionStorage' && !storageUtil.browserHasSessionStorage()) {\n    util.warn('This browser doesn\\'t support sessionStorage. Switching to cookie-based storage.');\n    options.storage = 'cookie';\n  }\n\n  var storage;\n\n  switch (options.storage) {\n    case 'localStorage':\n      storage = storageBuilder(localStorage, config.TOKEN_STORAGE_NAME);\n      break;\n\n    case 'sessionStorage':\n      storage = storageBuilder(sessionStorage, config.TOKEN_STORAGE_NAME);\n      break;\n\n    case 'cookie':\n      storage = storageBuilder(storageUtil.getCookieStorage(options), config.TOKEN_STORAGE_NAME);\n      break;\n\n    default:\n      throw new AuthSdkError('Unrecognized storage option');\n  }\n\n  var clock = SdkClock.create(sdk, options);\n  var tokenMgmtRef = {\n    clock: clock,\n    options: options,\n    emitter: new Emitter(),\n    expireTimeouts: {},\n    renewPromise: {}\n  };\n  this.add = util.bind(add, this, sdk, tokenMgmtRef, storage);\n  this.get = util.bind(getAsync, this, sdk, tokenMgmtRef, storage);\n  this.remove = util.bind(remove, this, tokenMgmtRef, storage);\n  this.clear = util.bind(clear, this, tokenMgmtRef, storage);\n  this.renew = util.bind(renew, this, sdk, tokenMgmtRef, storage);\n  this.on = util.bind(tokenMgmtRef.emitter.on, tokenMgmtRef.emitter);\n  this.off = util.bind(tokenMgmtRef.emitter.off, tokenMgmtRef.emitter);\n  setExpireEventTimeoutAll(sdk, tokenMgmtRef, storage);\n}\n\nmodule.exports = TokenManager;","map":{"version":3,"sources":["/app/node_modules/@okta/okta-auth-js/lib/TokenManager.js"],"names":["util","require","AuthSdkError","storageUtil","Q","Emitter","config","storageBuilder","SdkClock","DEFAULT_OPTIONS","autoRenew","storage","expireEarlySeconds","getExpireTime","tokenMgmtRef","token","expireTime","expiresAt","options","hasExpired","clock","now","emitExpired","key","emitter","emit","emitError","error","clearExpireEventTimeout","clearTimeout","expireTimeouts","renewPromise","clearExpireEventTimeoutAll","hasOwnProperty","setExpireEventTimeout","sdk","expireEventWait","Math","max","expireEventTimeout","setTimeout","setExpireEventTimeoutAll","tokenStorage","getStorage","e","add","isObject","scopes","idToken","accessToken","setStorage","get","getAsync","Promise","resolve","tokenPromise","renew","remove","existingPromise","reject","then","freshTokens","freshToken","Array","find","oldToken","catch","err","name","finally","clear","clearStorage","TokenManager","extend","removeNils","browserHasLocalStorage","warn","browserHasSessionStorage","localStorage","TOKEN_STORAGE_NAME","sessionStorage","getCookieStorage","create","bind","on","off","module","exports"],"mappings":"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","sourcesContent":["/*!\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\n *\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *\n * See the License for the specific language governing permissions and limitations under the License.\n *\n */\n\n/* eslint complexity:[0,8] max-statements:[0,21] */\nvar util = require('./util');\nvar AuthSdkError = require('./errors/AuthSdkError');\nvar storageUtil = require('./browser/browserStorage');\nvar Q = require('q');\nvar Emitter = require('tiny-emitter');\nvar config = require('./config');\nvar storageBuilder = require('./storageBuilder');\nvar SdkClock = require('./clock');\n\nvar DEFAULT_OPTIONS = {\n  autoRenew: true,\n  storage: 'localStorage',\n  expireEarlySeconds: 30\n};\n\nfunction getExpireTime(tokenMgmtRef, token) {\n  var expireTime = token.expiresAt - tokenMgmtRef.options.expireEarlySeconds;\n  return expireTime;\n}\n\nfunction hasExpired(tokenMgmtRef, token) {\n  var expireTime = getExpireTime(tokenMgmtRef, token);\n  return expireTime <= tokenMgmtRef.clock.now();\n}\n\nfunction emitExpired(tokenMgmtRef, key, token) {\n  tokenMgmtRef.emitter.emit('expired', key, token);\n}\n\nfunction emitError(tokenMgmtRef, error) {\n  tokenMgmtRef.emitter.emit('error', error);\n}\n\nfunction clearExpireEventTimeout(tokenMgmtRef, key) {\n  clearTimeout(tokenMgmtRef.expireTimeouts[key]);\n  delete tokenMgmtRef.expireTimeouts[key];\n\n  // Remove the renew promise (if it exists)\n  delete tokenMgmtRef.renewPromise[key];\n}\n\nfunction clearExpireEventTimeoutAll(tokenMgmtRef) {\n  var expireTimeouts = tokenMgmtRef.expireTimeouts;\n  for (var key in expireTimeouts) {\n    if (!expireTimeouts.hasOwnProperty(key)) {\n      continue;\n    }\n    clearExpireEventTimeout(tokenMgmtRef, key);\n  }\n}\n\nfunction setExpireEventTimeout(sdk, tokenMgmtRef, key, token) {\n  var expireTime = getExpireTime(tokenMgmtRef, token);\n  var expireEventWait = Math.max(expireTime - tokenMgmtRef.clock.now(), 0) * 1000;\n\n  // Clear any existing timeout\n  clearExpireEventTimeout(tokenMgmtRef, key);\n\n  var expireEventTimeout = setTimeout(function() {\n    emitExpired(tokenMgmtRef, key, token);\n  }, expireEventWait);\n\n  // Add a new timeout\n  tokenMgmtRef.expireTimeouts[key] = expireEventTimeout;\n}\n\nfunction setExpireEventTimeoutAll(sdk, tokenMgmtRef, storage) {\n  try {\n    var tokenStorage = storage.getStorage();\n  } catch(e) {\n    // Any errors thrown on instantiation will not be caught,\n    // because there are no listeners yet\n    emitError(tokenMgmtRef, e);\n    return;\n  }\n\n  for(var key in tokenStorage) {\n    if (!tokenStorage.hasOwnProperty(key)) {\n      continue;\n    }\n    var token = tokenStorage[key];\n    setExpireEventTimeout(sdk, tokenMgmtRef, key, token);\n  }\n}\n\nfunction add(sdk, tokenMgmtRef, storage, key, token) {\n  var tokenStorage = storage.getStorage();\n  if (!util.isObject(token) ||\n      !token.scopes ||\n      (!token.expiresAt && token.expiresAt !== 0) ||\n      (!token.idToken && !token.accessToken)) {\n    throw new AuthSdkError('Token must be an Object with scopes, expiresAt, and an idToken or accessToken properties');\n  }\n  tokenStorage[key] = token;\n  storage.setStorage(tokenStorage);\n  setExpireEventTimeout(sdk, tokenMgmtRef, key, token);\n}\n\nfunction get(storage, key) {\n  var tokenStorage = storage.getStorage();\n  return tokenStorage[key];\n}\n\nfunction getAsync(sdk, tokenMgmtRef, storage, key) {\n  return Q.Promise(function(resolve) {\n    var token = get(storage, key);\n    if (!token || !hasExpired(tokenMgmtRef, token)) {\n      return resolve(token);\n    }\n\n    var tokenPromise = tokenMgmtRef.options.autoRenew\n      ? renew(sdk, tokenMgmtRef, storage, key)\n      : remove(tokenMgmtRef, storage, key);\n\n    return resolve(tokenPromise);\n  });\n}\n\nfunction remove(tokenMgmtRef, storage, key) {\n  // Clear any listener for this token\n  clearExpireEventTimeout(tokenMgmtRef, key);\n\n  // Remove it from storage\n  var tokenStorage = storage.getStorage();\n  delete tokenStorage[key];\n  storage.setStorage(tokenStorage);\n}\n\nfunction renew(sdk, tokenMgmtRef, storage, key) {\n  // Multiple callers may receive the same promise. They will all resolve or reject from the same request.\n  var existingPromise = tokenMgmtRef.renewPromise[key];\n  if (existingPromise) {\n    return existingPromise;\n  }\n\n  try {\n    var token = get(storage, key);\n    if (!token) {\n      throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\n    }\n  } catch (e) {\n    return Q.reject(e);\n  }\n\n  // Remove existing autoRenew timeout for this key\n  clearExpireEventTimeout(tokenMgmtRef, key);\n\n  // Store the renew promise state, to avoid renewing again\n  tokenMgmtRef.renewPromise[key] = sdk.token.renew(token)\n    .then(function(freshTokens) {\n      var freshToken = freshTokens;\n      // With PKCE flow we will receive multiple tokens. Find the one we are looking for\n      if (freshTokens instanceof Array) {\n        freshToken = freshTokens.find(function(freshToken) {\n          return (freshToken.idToken && token.idToken) || (freshToken.accessToken && token.accessToken);\n        });\n      }\n\n      var oldToken = get(storage, key);\n      if (!oldToken) {\n        // It is possible to enter a state where the tokens have been cleared\n        // after a renewal request was triggered. To ensure we do not store a\n        // renewed token, we verify the promise key doesn't exist and return.\n        return;\n      }\n      add(sdk, tokenMgmtRef, storage, key, freshToken);\n      tokenMgmtRef.emitter.emit('renewed', key, freshToken, oldToken);\n      return freshToken;\n    })\n    .catch(function(err) {\n      if (err.name === 'OAuthError' || err.name === 'AuthSdkError') {\n        remove(tokenMgmtRef, storage, key);\n        emitError(tokenMgmtRef, err);\n      }\n      throw err;\n    })\n    .finally(function() {\n      // Remove existing promise key\n      delete tokenMgmtRef.renewPromise[key];\n    });\n\n  return tokenMgmtRef.renewPromise[key];\n}\n\nfunction clear(tokenMgmtRef, storage) {\n  clearExpireEventTimeoutAll(tokenMgmtRef);\n  storage.clearStorage();\n}\n\nfunction TokenManager(sdk, options) {\n  options = util.extend({}, DEFAULT_OPTIONS, util.removeNils(options));\n\n  if (options.storage === 'localStorage' && !storageUtil.browserHasLocalStorage()) {\n    util.warn('This browser doesn\\'t support localStorage. Switching to sessionStorage.');\n    options.storage = 'sessionStorage';\n  }\n\n  if (options.storage === 'sessionStorage' && !storageUtil.browserHasSessionStorage()) {\n    util.warn('This browser doesn\\'t support sessionStorage. Switching to cookie-based storage.');\n    options.storage = 'cookie';\n  }\n\n  var storage;\n  switch(options.storage) {\n    case 'localStorage':\n      storage = storageBuilder(localStorage, config.TOKEN_STORAGE_NAME);\n      break;\n    case 'sessionStorage':\n      storage = storageBuilder(sessionStorage, config.TOKEN_STORAGE_NAME);\n      break;\n    case 'cookie':\n      storage = storageBuilder(storageUtil.getCookieStorage(options), config.TOKEN_STORAGE_NAME);\n      break;\n    default:\n      throw new AuthSdkError('Unrecognized storage option');\n  }\n\n  var clock = SdkClock.create(sdk, options);\n  var tokenMgmtRef = {\n    clock: clock,\n    options: options,\n    emitter: new Emitter(),\n    expireTimeouts: {},\n    renewPromise: {}\n  };\n\n  this.add = util.bind(add, this, sdk, tokenMgmtRef, storage);\n  this.get = util.bind(getAsync, this, sdk, tokenMgmtRef, storage);\n  this.remove = util.bind(remove, this, tokenMgmtRef, storage);\n  this.clear = util.bind(clear, this, tokenMgmtRef, storage);\n  this.renew = util.bind(renew, this, sdk, tokenMgmtRef, storage);\n  this.on = util.bind(tokenMgmtRef.emitter.on, tokenMgmtRef.emitter);\n  this.off = util.bind(tokenMgmtRef.emitter.off, tokenMgmtRef.emitter);\n\n  setExpireEventTimeoutAll(sdk, tokenMgmtRef, storage);\n}\n\nmodule.exports = TokenManager;\n"]},"metadata":{},"sourceType":"script"}